---
title: "Журнал встречи Исследовательской лаборатории Monero от 27.04.2022"  
date: "2022-04-27"  
categories:
  - "Журнал встречи"
tags:
  - "Журнал встречи"
---

## _Журнал встречи:_

_**\<UkoeHB>**_ время встречи https://github.com/monero-project/meta/issues/697  
_**\<UkoeHB>**_ 1. приветствия  
_**\<UkoeHB>**_ привет!  
_**\<selsta>**_ hi  
_**\<jberman[m]>**_ howdy  
_**\<xmr-ack[m]>**_ hola  
_**\<mj-xmr[m]>**_ Bonjour  
_**\<Rucknium[m]>**_ Hi  
_**\<cryptogrampy[m]>**_ hi  
_**\<UkoeHB>**_ 2. Обновления, над чем работаете?  
_**\<UkoeHB>**_ я: работа в ключе seraphis (я реализовал эталонные бинарные наборы, затем предстоит обсуждение/возможная реализация индекса адресов 16/2 jamtis и уже потом предстоит заняться дискретизированными комиссиями)  
_**\<mj-xmr[m]>**_ а) Я добился некоторого прогресса в алгоритме выбора приманки и обобщил как результаты и стратегию по этой ссылке:  
_**\<mj-xmr[m]>**_ https://github.com/mj-xmr/monero-mrl-mj/tree/decoy/decoy  
_**\<mj-xmr[m]>**_ Вкратце: мы будем проводить статистический анализ с помощью Rucknium и jberman  
_**\<mj-xmr[m]>**_ b) Я отлично поболтал с ArticMine и endor00 по поводу следующей (параллельной) задачи в ключе симуляции системы поведения (комиссия и размер блока) в случае внезапного увеличения транзакций в сети. И теперь я знаю, как это все должно работать, немного лучше  
_**\<Rucknium[m]>**_ Я работаю над оценкой эффекта (если таковой будет) от увеличения комиссии на minexmr пуле с 1,0% до 1,1% с 1 апреля. Для меня наиболее очевидная статистическая модель — это тест на структурный разрыв во временном ряду. Я начал собирать данные, используя SQL-таблицы от Neptune  
_**\<Rucknium[m]>**_ Я думаю, что этот исследовательский опыт может быть немного щекотливым. Позже я собираюсь рассчитать статистическую мощность данного теста. Если тест не сможет обнаружить падение (или рост) доли блоков minexmr менее чем на 1-2%, то я, вероятно, просто поделюсь результатами здесь, а не на Reddit, поскольку я думаю, что простым пользователям будет трудно различить эти два показателя, что приведёт к утверждению, что заявления «Не было никакого эффекта» и «Данные и обстоятельства были таковы, что никакого эффекта не последовало» станут основными умозаключениями моего исследования  
_**\<jberman[m]>**_ хочу отметить, что добавлена поддержка тегов просмотра в обозревателе блоков + monero-lws, а также я оказывал помощь с monero-python (в добавлении поддержки тегов просмотра, [спасибо plowsof], и в исправлении уязвимости, о которой сообщает kayabaNerve, которая позволяет отправителю получить данные о получателе)  
_**\<UkoeHB>**_ спасибо, парни  
_**\<UkoeHB>**_ 3. предлагаю обсудить более крупные адресные теги jamtis (и соответствующие адресные индексы)  
_**\<UkoeHB>**_ Есть ли у кого-нибудь комментарии/вопросы по этому поводу (кроме меня)?  
_**\<Rucknium[m]>**_ Вопрос: Что такое MAC?  
_**\<UkoeHB>**_ Я придумал скорректированный CBC режим (цепной блочный шифр) для Blowfish, который, похоже, будет работать для шифрованных текстов с кратным размером, отличным от размера блока  
_**\<Rucknium[m]>**_ Кроме того, связано ли это с расчетами «вероятности столкновения», которые мы с вами обсуждали несколько месяцев назад?  
_**\<UkoeHB>**_ Rucknium[m]: при шифровании чего-либо вы можете добавить небольшой фрагмент данных в конце процедуры. При расшифровке, если вы воссоздаете эту добавленную конечную часть (MAC), то существует очень высокая вероятность того, что дешифровка пройдёт успешно (т.е. расшифрованный текст не является тарабарщиной).  
_**\<UkoeHB>**_ Обычно MAC-адреса составляют ~16 байт. В случае адресных тегов jamtis MAC просто действует как фильтр при дешифровке (что очень похоже на теги просмотра).  
_**\<UkoeHB>**_ и поскольку он действует как фильтр, то размер может быть весьма небольшим (1-2 байта)  
_**\<UkoeHB>**_ Если у кого-то есть лучшее имя для адресного тега MAC, я был бы рад использовать его, lol  
_**\<UkoeHB>**_ Rucknium[m]: вероятность столкновения, не могли бы вы напомнить, что это такое?  
_**\<kayabaNerve>**_ jberman[m]: Это было только тогда, когда он сам сканировал его, чего, скорее всего, не происходило, но это, определенно, очень важный патч для общей безопасности :)  
_**\<UkoeHB>**_ оу, в seraphis присутствуют раздавленные хеши? это всё меняет  
_**\<kayabaNerve>**_ просто чтобы убедиться, что я правильно понимаю — MAC можно сравнить с контрольной суммой BTC из 6 символов / 4 байта для Bech32, верно?  
_**\<UkoeHB>**_ kayabaNerve: на практике это просто несколько нулевых битов, добавленных к открытому тексту, а затем вы проверяете, равны ли эти биты нулю после расшифровки  
_**\<kayabaNerve>**_ Я не буду выступать за использование кода BCH, поскольку буквально никто не мешает использовать их для обнаружения ошибок, и вы никогда не должны автоматически исправлять их  
_**\<kayabaNerve>**_ Угу, Bech32 использует константу... 1? А затем Bech32m использует константу, которая не допускает податливости с помощью заполнения 0  
_**\<kayabaNerve>**_ где это предлагается использовать?  
_**\<UkoeHB>**_ kayabaNerve: https://gist.github.com/tevador/50160d160d24cfc6c52ae02eb3d17024?permalink_comment_id=4144862#gistcomment-4144862  
_**\<merope>**_ MAC-адреса предназначены не для исправления ошибок, а для обнаружения ошибок расшифровки или несанкционированного доступа. Без MAC кто-то мог бы манипулировать зашифрованным текстом и изменять конечные результат  
_**\<kayabaNerve>**_ спасибо  
_**\<UkoeHB>**_ если вы прокрутите страницу вверх, то в понедельник я сделал комментарий, в котором кратко изложил текущую ситуацию  
_**\<jberman[m]>**_ @UkoeHB, удалось ли вам провести дополнительный сравнительный анализ или может быть вы сможете прокомментировать, как именно это повлияет на общее время сканирования? Я не совсем понимаю это из вашего комментария, учитывая, что MAC выглядит лучше. И еще сможем ли мы ожидать, что увеличение размера байта фактически сократит время сканирования?  
_**\<UkoeHB>**_ jberman[m]: Я еще буду работать над этим сегодня  
_**\<UkoeHB>**_ увеличение размера с 8 -> 18 увеличит шифры blowfish с 1 до 3, но увеличение mac с 1 -> 2 байт снизит общую стоимость фильтра сбоев на 1/256 (для сбоев потребуется по крайней мере одна дорогостоящая операция EC)  
_**\<kayabaNerve>**_ Спасибо за разъяснения! Все это имеет смысл для меня. Здесь определенно нет варианта использования BCH (я предположил, что это было использовано только для адресов, не понимая различия тегов, извините)  
_**\<UkoeHB>**_ На сегодняшний день более важным вопросом является размер адресного индекса (7 байт или 16 байт).  
_**\<UkoeHB>**_ сейчас у нас есть 8-байтовые адресные индексы (обычно разделенные на 4-байтовый адресный индекс и 4-байтовый индекс учетной записи)  
_**\<selsta>**_ не понял, увеличить с 8 до 16? или уменьшить до 7?  
_**\<UkoeHB>**_ да  
_**\<UkoeHB>**_ основная цель 16 байтов — что даст нам надежную генерацию случайных адресов  
_**\<selsta>**_ Я бы сначала проверил, подходят ли 16 байт для рационального использования оперативной памяти  
_**\<jberman[m]>**_ Мне нравится эта идея. Но это, скорее, относится к коллизиям, поскольку позволяет случайным образом сгенерировать адрес, не беспокоясь об этих самых коллизиях. Сегодня вам нужно либо поддерживать актуальное состояние подадресов, либо использовать интегрированные адреса. Поддержание состояния в кошельках не так-то просто во всех смыслах, а у интегрированных адресов есть ряд недостатков, которые уже не раз обсуждались  
_**\<selsta>**_ хорошо, если вы хотите использовать его, как говорит jberman[m], это может сделать sehse  
_**\<UkoeHB>**_ selsta: что вы имеете в виду под оперативной памятью? Я бы просто использовал массив uchar (кошельки могут интерпретировать индекс, как хотят)  
_**\<UkoeHB>**_ 16-байтовые индексы эквивалентны разделению интегрированной адресной части на составляющие адреса (добавление 8 байт)  
_**\<selsta>**_ UkoeHB: я имел в виду, если кто-то генерирует все возможные адреса или кто-то хочет просто случайным образом генерировать адреса  
_**\<UkoeHB>**_ все новые кошельки должны в первую очередь использовать генерацию случайных адресов (будут контролироваться только биты учетной записи)  
_**\<selsta>**_ как будет работать восстановление в этом случае?  
_**\<selsta>**_ в настоящее время они генерируются последовательно, и во время восстановления появляется возможность предварительного просмотра  
_**\<UkoeHB>**_ selsta: возможно, вы захотите почитать о jamtis немного больше - https://gist.github.com/tevador/50160d160d24cfc6c52ae02eb3d17024  
_**\<selsta>**_ да, будет лучше, если я останусь в стороне от этой дискуссии, lol  
_**\<UkoeHB>**_ адреса будут иметь "тег адреса" (зашифрованный индекс адреса), а выходные данные по цепочке будут иметь зашифрованные теги адресов  
_**\<jberman[m]>**_ это избавляет от необходимости забегать вперед, позволяя вам расшифровывать, чтобы точно понимать, какой адрес был использован в конкретном случае  
_**\<selsta>**_ я не совсем в курсе этого предложения  
_**\<UkoeHB>**_ во время сканирования вы расшифровываете, затем расшифровываете тег адреса, чтобы получить индекс, а затем пытаетесь создать заново секретный ключ  
_**\<selsta>**_ это хорошее улучшение  
_**\<UkoeHB>**_ тег адреса содержит mac, поэтому вы не тратите кучу времени на воссоздание ключей тестового формата  
_**\<UkoeHB>**_ создать заново секретный ключ траты*  
_**\<UkoeHB>**_ причина, по которой мы обсуждаем изменение размера, заключается в том, что эти адресные теги хранятся в цепочке  
_**\<jberman[m]>**_ стоит отметить, что 10 байт на вывод, вероятно, были бы более значимыми, если бы была реализована идея о том, чтобы все транзакции использовали 16 выходов: https://github.com/monero-project/research-lab/issues/96  
_**\<UkoeHB>**_ предположим, что так  
_**\<gingeropolous>**_ мне кажется, что поощрение пользователей к постоянному использованию случайных адресов (в отличие от повторного использования подадресов) для предотвращения внеполосных ассоциаций того стоит, особенно если альтернатива настолько сложна в реализации, чтобы привести к тому, что кошельки этого не сделают или не будут поддерживать  
_**\<UkoeHB>**_ что ж, вопрос в том, можете ли вы по-прежнему создавать случайные адреса с гораздо меньшими индексами (5 байт в 7-байтовом индексе, который имеет 2-байтовый индекс учетной записи)  
_**\<gingeropolous>**_ я полностью готов к проверке, когда это будет реализовано  
_**\<jberman[m]>**_ некоторые кошельки даже не имеют механизмов защиты (например, у вас есть кошелек на одном компьютере и еще один кошелек на другом компьютере, и эти 2 кошелька не взаимодействуют друг с другом)  
_**\<UkoeHB>**_ Похоже, что тут нет никакой оппозиции (если бы здесь был tevador, было бы больше возражений по этому поводу). Я проведу тесты производительности, сравнивая теги адресов с 7/1 и 16/2 jamtis. Если у 16/2 не будет явных проблем с производительностью, то я его реализую уже в ближайшее время. И тогда мы сможем вернуться к этому вопросу в ближайшем будущем (или возможно, что у кого-то появятся возражения)  
_**\<UkoeHB>**_ Мы приближаемся к окончанию встречи. Есть какие-нибудь вопросы / комментарии?  
_**\<cryptogrampy[m]>**_ Очень интересно, особенно то, что кошелек, предназначенный только для просмотра в точках продаж, ничего не знает о том, в каком индексе вложенного адреса находится кошелек с ключом  
_**\<cryptogrampy[m]>**_ Я и работаю над этим прямо сейчас с помощью HotBox :) Но пока можно использовать только интегрированные адреса.  
_**\<selsta>**_ Я просто хотел вкратце поговорить о многозначном аудите  
_**\<UkoeHB>**_ cryptogrampy[m]: как вы думаете, случайная генерация решит эту проблему?  
_**\<UkoeHB>**_ selsta: окей  
_**\<selsta>**_ Я не думаю, что мы должны проводить аудит мультиподписи перед хардфорком, но мы определенно должны провести аудит до начала использования мультиподписей  
_**\<UkoeHB>**_ Возражений нет  
_**\<selsta>**_ Проблема в том, что применяемая криптография не описана надлежащим образом, и я не думаю, что UkoeHB заинтересован в ее описании  
_**\<selsta>**_ Идеи, как бы мы могли решить это?  
_**\<selsta>**_ Без описания аудиторы, вероятно, потратят намного больше времени на аудит и, возможно, что-то неправильно поймут  
_**\<UkoeHB>**_ Другими словами, нам нужен UkoeHB, lol  
_**\<selsta>**_ UkoeHB: Я понимаю, что работать над Seraphis гораздо интереснее :D  
_**\<UkoeHB>**_ Это также и обязательство по времени  
_**\<cryptogrampy[m]>**_ UkoeHB: Для варианта использования HotShop я бы хотел сгенерировать Randomsubaddress() (выводит подадрес, достаточно защищенный от коллизий), особенно для сбора данных о комиссиях.  Устройство, где производится сбор данных о комиссиях, использует основной ключ и ключ просмотра и не имеет контакта с кошельком, где находится ключ траты. Кошелек с ключом траты в настоящее время понятия не имеет, что использовался субадрес с индексом 100000000  
_**\<UkoeHB>**_ cryptogrampy[m]: должно помочь  
_**\<selsta>**_ может быть, luigi1111 хочет этим заняться  
_**\<Rucknium[m]>**_ Может, coin student 2048 хочет помочь нам?  
_**\<UkoeHB>**_ или будет*, сейчас у меня нет более точной информации  
_**\<jberman[m]>**_ я хотел попросить coinstudent посмотреть теги просмотра  
_**\<selsta>**_ думаю, что мы могли бы получить финансирование для тех, кто захочет этим заняться  
_**\<jberman[m]>**_ <UkoeHB> моя математическая модель может стать критически ошибочной, и 50% вероятность коллизии составляет порядка нескольких миллиардов сгенерированных подадресов. И было бы неплохо получить ответ на этот вопрос  
_**\<cryptogrampy[m]>**_ UkoeHB: это уже несколько раз обсуждалось на github, в смысле вопрос по поводу устаревания интегрированных адресов, но я думаю, что теги адресов могут быть последним гвоздем в гроб, необходимым для избавления от интегрированных адресов  
_**\<selsta>**_ Запуск Haveno без аудита может означать, что кража средств, расположенных на бирже, это только вопрос времени. По крайней мере, с аудитом эта вероятность снижается  
_**\<Rucknium[m]>**_ Я думаю, что фонд MAGIC Monero также мог бы внести немного денег, чтобы помочь в проведении аудита. Разумеется, комитету необходимо будет одобрить выделение этих средств  
_**\<selsta>**_ Rucknium[m]: Я поговорил с sgp, и он также предложил поговорить с MAGIC  
_**\<Rucknium[m]>**_ Я имею в виду, что MAGIC могла бы финансировать и саму рецензию. Но есть нюанс, для получения средств от MAGIC мы должны пройти KYC  
_**\<selsta>**_ давайте посмотрим, может, в этом заинтересованы costudent2048 или dangerousfreedom  
_**\<mj-xmr[m]>**_ звучит отлично, в том числе из-за требования KYC. Аудиты более формальны, чем обычная разработка кода  
_**\<mj-xmr[m]>**_ Я имею в виду, KYC в данном случае не повредит процессу аудита  
_**\<selsta>**_ хорошо, спасибо  
_**\<UkoeHB>**_ Спасибо всем за участие!  

---

_Источник: [Monero Research Lab Meeting - Wed 27 April 2022 @ 17:00 UTC #697](https://github.com/monero-project/meta/issues/697)_

_Перевод: [Mr. Pickles](https://t.me/v1docq47)_  
_Коррекция: [Kukima](https://t.me/Kukima)_
